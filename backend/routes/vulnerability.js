import express from 'express';
import vulnerabilityService from '../services/vulnerabilityService.js';
import webAppService from '../services/webAppService.js';
import intelligenceService from '../services/intelligenceService.js';
import exploitationService from '../services/exploitationService.js';
import mobileSecurityService from '../services/mobileSecurityService.js';
import obfuscationService from '../services/obfuscationService.js';
import postExploitationService from '../services/postExploitationService.js';
import aiAssistantService from '../services/aiAssistantService.js';

const router = express.Router();

// CVE and Vulnerability Routes
router.get('/cve/search', async (req, res, next) => {
  try {
    const { keyword, limit } = req.query;
    const result = await vulnerabilityService.searchCVE(keyword, limit);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

router.get('/cve/:cveId', async (req, res, next) => {
  try {
    const result = await vulnerabilityService.getCVEDetails(req.params.cveId);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

router.post('/scan', async (req, res, next) => {
  try {
    const { target, scanType } = req.body;
    const result = await vulnerabilityService.vulnerabilityScan(target, scanType);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

// Web Application Security Routes
router.post('/webapp/sql-injection', async (req, res, next) => {
  try {
    const { url, params } = req.body;
    const result = await webAppService.sqlInjectionScan(url, params);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

router.post('/webapp/xss', async (req, res, next) => {
  try {
    const { url } = req.body;
    const result = await webAppService.xssScan(url);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

router.post('/webapp/directory-bruteforce', async (req, res, next) => {
  try {
    const { url, wordlist } = req.body;
    const result = await webAppService.directoryBruteforce(url, wordlist);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

router.post('/webapp/comprehensive', async (req, res, next) => {
  try {
    const { url } = req.body;
    const result = await webAppService.comprehensiveWebScan(url);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

// Intelligence Routes
router.get('/intelligence/ip/:ip', async (req, res, next) => {
  try {
    const result = await intelligenceService.checkIPReputation(req.params.ip);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

router.get('/intelligence/email/:email', async (req, res, next) => {
  try {
    const result = await intelligenceService.validateEmail(req.params.email);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

router.get('/intelligence/breaches/:email', async (req, res, next) => {
  try {
    const result = await intelligenceService.checkBreaches(req.params.email);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

router.get('/intelligence/phone/:number', async (req, res, next) => {
  try {
    const result = await intelligenceService.phoneLookup(req.params.number);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

router.get('/intelligence/temp-mail', async (req, res, next) => {
  try {
    const result = await intelligenceService.generateTempMail();
    res.json(result);
  } catch (error) {
    next(error);
  }
});

// Exploitation Routes
router.post('/exploitation/payload', async (req, res, next) => {
  try {
    const { type, options } = req.body;
    const result = await exploitationService.generatePayload(type, options);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

router.get('/exploitation/exploits', async (req, res, next) => {
  try {
    const { category, platform } = req.query;
    const result = await exploitationService.listExploits(category, platform);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

router.post('/exploitation/custom', async (req, res, next) => {
  try {
    const { target, vulnerability } = req.body;
    const result = await exploitationService.generateCustomExploit(target, vulnerability);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

// Mobile Security Routes
router.post('/mobile/apk-analyze', async (req, res, next) => {
  try {
    const result = await mobileSecurityService.analyzeAPK(req.body.file || {});
    res.json(result);
  } catch (error) {
    next(error);
  }
});

router.post('/mobile/scan', async (req, res, next) => {
  try {
    const { platform, appId } = req.body;
    const result = await mobileSecurityService.scanMobileApp(platform, appId);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

router.post('/mobile/ios-analyze', async (req, res, next) => {
  try {
    const result = await mobileSecurityService.iosSecurityAnalysis(req.body.file || {});
    res.json(result);
  } catch (error) {
    next(error);
  }
});

router.post('/mobile/forensics', async (req, res, next) => {
  try {
    const { deviceType, options } = req.body;
    const result = await mobileSecurityService.mobileForensics(deviceType, options);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

// Obfuscation Routes
router.post('/obfuscation/script', async (req, res, next) => {
  try {
    const { code, language } = req.body;
    const result = obfuscationService.obfuscateScript(code, language);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

router.post('/obfuscation/encode', async (req, res, next) => {
  try {
    const { payload, encodingType } = req.body;
    const result = await obfuscationService.encodePayload(payload, encodingType);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

router.post('/obfuscation/ps1-to-exe', async (req, res, next) => {
  try {
    const { scriptContent, outputName } = req.body;
    const result = await obfuscationService.ps1ToExe(scriptContent, outputName);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

router.post('/obfuscation/exe', async (req, res, next) => {
  try {
    const { file, level } = req.body;
    const result = await obfuscationService.obfuscateExecutable(file, level);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

// Post-Exploitation Routes
router.get('/post-exploit/privesc/:platform', async (req, res, next) => {
  try {
    const { method } = req.query;
    const result = await postExploitationService.privilegeEscalation(req.params.platform, method);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

router.get('/post-exploit/persistence/:platform', async (req, res, next) => {
  try {
    const result = await postExploitationService.persistenceTechniques(req.params.platform);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

router.post('/post-exploit/exfiltration', async (req, res, next) => {
  try {
    const { method, options } = req.body;
    const result = await postExploitationService.dataExfiltration(method, options);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

router.post('/post-exploit/lateral-movement', async (req, res, next) => {
  try {
    const { network, technique } = req.body;
    const result = await postExploitationService.lateralMovement(network, technique);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

// AI Assistant Routes
router.post('/ai/chat', async (req, res, next) => {
  try {
    const { message, sessionId } = req.body;
    const result = await aiAssistantService.chat(message, sessionId);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

router.get('/ai/history/:sessionId', async (req, res, next) => {
  try {
    const result = await aiAssistantService.getConversationHistory(req.params.sessionId);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

router.delete('/ai/history/:sessionId', async (req, res, next) => {
  try {
    const result = await aiAssistantService.clearConversation(req.params.sessionId);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

export default router;
