import axios from 'axios';
import { logger } from '../config/logger.js';
import { AppError } from '../middleware/errorHandler.js';

export class VulnerabilityService {
  constructor() {
    this.cveApiBase = 'https://services.nvd.nist.gov/rest/json/cves/2.0';
    this.exploitDbBase = 'https://www.exploit-db.com';
  }

  async searchCVE(keyword, limit = 10) {
    try {
      logger.info(`Searching CVE database for: ${keyword}`);
      
      // Note: In production, use proper NVD API with rate limiting
      const response = await axios.get(this.cveApiBase, {
        params: {
          keywordSearch: keyword,
          resultsPerPage: limit
        },
        timeout: 15000
      });

      const vulnerabilities = response.data.vulnerabilities || [];
      
      return {
        keyword,
        totalResults: response.data.totalResults || 0,
        vulnerabilities: vulnerabilities.map(v => ({
          id: v.cve.id,
          description: v.cve.descriptions?.[0]?.value || 'No description',
          publishedDate: v.cve.published,
          lastModified: v.cve.lastModified,
          severity: v.cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseSeverity || 'UNKNOWN',
          score: v.cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore || 0,
          vector: v.cve.metrics?.cvssMetricV31?.[0]?.cvssData?.vectorString || 'N/A',
          references: v.cve.references?.slice(0, 5).map(r => r.url) || []
        })),
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      logger.error(`CVE search failed: ${error.message}`);
      throw new AppError(`CVE search failed: ${error.message}`, 500);
    }
  }

  async getCVEDetails(cveId) {
    try {
      logger.info(`Fetching CVE details for: ${cveId}`);
      
      const response = await axios.get(`${this.cveApiBase}`, {
        params: {
          cveId: cveId
        },
        timeout: 15000
      });

      const vuln = response.data.vulnerabilities?.[0];
      
      if (!vuln) {
        throw new AppError('CVE not found', 404);
      }

      return {
        id: vuln.cve.id,
        description: vuln.cve.descriptions?.[0]?.value || 'No description',
        publishedDate: vuln.cve.published,
        lastModified: vuln.cve.lastModified,
        severity: vuln.cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseSeverity || 'UNKNOWN',
        score: vuln.cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore || 0,
        vector: vuln.cve.metrics?.cvssMetricV31?.[0]?.cvssData?.vectorString || 'N/A',
        references: vuln.cve.references?.map(r => ({
          url: r.url,
          source: r.source
        })) || [],
        weaknesses: vuln.cve.weaknesses?.map(w => ({
          type: w.type,
          description: w.description?.[0]?.value
        })) || [],
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      logger.error(`CVE details fetch failed: ${error.message}`);
      throw new AppError(`Failed to fetch CVE details: ${error.message}`, 500);
    }
  }

  async searchExploits(keyword, limit = 20) {
    try {
      logger.info(`Searching exploits for: ${keyword}`);
      
      // Mock exploit search results (in production, integrate with Exploit-DB API or scraping)
      const mockExploits = [
        {
          id: 'EDB-12345',
          title: `${keyword} - Remote Code Execution`,
          platform: 'linux',
          type: 'remote',
          author: 'Security Researcher',
          date: '2024-01-15',
          verified: true
        },
        {
          id: 'EDB-12346',
          title: `${keyword} - SQL Injection`,
          platform: 'php',
          type: 'webapps',
          author: 'Pentester',
          date: '2024-01-10',
          verified: false
        }
      ];

      return {
        keyword,
        totalResults: mockExploits.length,
        exploits: mockExploits,
        timestamp: new Date().toISOString(),
        note: 'This is mock data. Integrate with Exploit-DB API for real exploits.'
      };
    } catch (error) {
      logger.error(`Exploit search failed: ${error.message}`);
      throw new AppError(`Exploit search failed: ${error.message}`, 500);
    }
  }

  async vulnerabilityScan(target, scanType = 'basic') {
    try {
      logger.info(`Running vulnerability scan on ${target} (type: ${scanType})`);
      
      const vulnerabilities = [];
      
      // Check for common vulnerabilities
      const checks = [
        {
          name: 'Open Ports',
          description: 'Checking for commonly exploited open ports',
          severity: 'INFO',
          status: 'completed'
        },
        {
          name: 'SSL/TLS Configuration',
          description: 'Checking SSL/TLS security',
          severity: 'INFO',
          status: 'completed'
        },
        {
          name: 'Security Headers',
          description: 'Checking HTTP security headers',
          severity: 'INFO',
          status: 'completed'
        }
      ];

      return {
        target,
        scanType,
        timestamp: new Date().toISOString(),
        checks,
        vulnerabilities,
        summary: {
          totalChecks: checks.length,
          totalVulnerabilities: vulnerabilities.length,
          critical: vulnerabilities.filter(v => v.severity === 'CRITICAL').length,
          high: vulnerabilities.filter(v => v.severity === 'HIGH').length,
          medium: vulnerabilities.filter(v => v.severity === 'MEDIUM').length,
          low: vulnerabilities.filter(v => v.severity === 'LOW').length
        }
      };
    } catch (error) {
      logger.error(`Vulnerability scan failed: ${error.message}`);
      throw new AppError(`Vulnerability scan failed: ${error.message}`, 500);
    }
  }
}

export default new VulnerabilityService();
